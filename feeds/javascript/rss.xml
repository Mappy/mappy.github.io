<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mappy Labs - javascript</title><link href="https://techblog.mappy.com/" rel="alternate"></link><link href="https://techblog.mappy.com/feeds/javascript/rss.xml" rel="self"></link><id>https://techblog.mappy.com/</id><updated>2018-01-31T00:00:00+01:00</updated><entry><title>Backbone isomorphique maison : comment ?</title><link href="https://techblog.mappy.com/comment-backbone-isomorphique.html" rel="alternate"></link><published>2018-01-31T00:00:00+01:00</published><updated>2018-01-31T00:00:00+01:00</updated><author><name>Nicolas Bétheuil, Grégory Paul, Manuel Emeriau</name></author><id>tag:techblog.mappy.com,2018-01-31:/comment-backbone-isomorphique.html</id><summary type="html">&lt;p&gt;Comment a t'on réécrit une librairie isomorphique Backbone maison ?&lt;/p&gt;</summary><content type="html">&lt;p&gt;Cet article fait écho a &lt;a href="/pourquoi-backbone-isomorphique.html"&gt;Backbone isomorphique maison : pourquoi ?&lt;/a&gt; Celui-ci va présenter comment AMIB a été construit.&lt;/p&gt;
&lt;p&gt;La première difficulté était déjà de définir l'attendu et le code que nous souhaitions écrire. Nous n'avons pas commencé par les tests contrairement à nos habitudes. Notre objectif était de mesurer rapidement si nous étions sur une piste intéressante, pour éventuellement l'abandonner et éviter de gaspiller notre temps.&lt;/p&gt;
&lt;p&gt;Nous savions que les interactions allaient se présenter de cette manière
&lt;img alt="première idée" src="/images/javascript/use-case.png"&gt;&lt;/p&gt;
&lt;p&gt;Nous avons donc commencé par écrire :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/fixtures/recursive-children-view/RecursiveChildrenView.js"&gt;notre première vue&lt;/a&gt; que nous avons rapidement étoffée&lt;/li&gt;
&lt;li&gt;pour avoir un modèle et un enfant,&lt;/li&gt;
&lt;li&gt;puis avec &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/fixtures/multiple-children-view/MultipleChildrenView.js"&gt;plusieurs enfants&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;puis avec un enfant &lt;a href="https://github.com/Mappy/amib/blob/master/fixtures/one-children-with-model/no-children-with-promise-model/NoChildrenWithPromiseModelView.js"&gt;avec un modèle asynchrone&lt;/a&gt;, on appelle ça une &lt;a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise"&gt;promesse&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L'intérêt de faire fonctionner ce moteur de rendu avec des modèles asynchrones est très simple : nous consommons des services pour afficher les résolutions d'itinéraire, on utilise pour cela des requêtes HTTP, AJAX côté client &amp;amp; &lt;code&gt;request&lt;/code&gt; côté serveur. Nous devions donc gérer l'asynchronisme de ces requêtes.&lt;/p&gt;
&lt;p&gt;La copie d'écran annotée en bleu ci-dessous montre l'imbrication des composants entre eux.
&lt;img alt="composants" src="/images/javascript/component.png"&gt;&lt;/p&gt;
&lt;p&gt;Comme Backbone ne fonctionne pas sous NodeJS à cause de sa dépendance avec JQuery (et l'usage du DOM), nous avons &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/nodify-backbone.js"&gt;surchargé/bouchonné les méthodes voulues&lt;/a&gt;. Nous avons donc pu exécuter une vue Backbone côté serveur. L'astuce de la &lt;a href="http://backbonejs.org/docs/backbone.html#section-162"&gt;ré-implémentation de setElement&lt;/a&gt; permet d'avoir la même interface de sortie. La différence porte juste sur la manière de retourner la vue Backbone afin qu'elle soit &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/render.js#L164"&gt;ajoutée soit au DOM dans le navigateur&lt;/a&gt; soit &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/render.js#L148"&gt;dans la réponse sous NodeJS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Nos gabaris/modèles (templates) sont des fichiers twig, l'idée est simplement d'importer ceux-ci en tant qu'objet twig via &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/node-twigify.js"&gt;cette magie&lt;/a&gt; et voilà.&lt;/p&gt;
&lt;p&gt;Vous pouvez voir l'usage &lt;a href="https://github.com/Mappy/amib/blob/73ac67cb25f336374a03cf26745d99f80667f927/renderToDom.client.spec.js#L39"&gt;côté client&lt;/a&gt; ou &lt;a href="https://github.com/Mappy/amib/blob/master/renderToString.server.spec.js#L23"&gt;côté serveur&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ci-dessous les exemples de la vraie vie :&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fr.mappy.com/itineraire/paris/lyon"&gt;Sans JS : en mode SEO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Sans JS : en mode SEO" src="/images/javascript/isomorph-no-js.png.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fr.mappy.com/#/13/M2/TItinerary/IFRParis%2075001-75116|TOLyon%2069001-69009|MOvoiture|PRcar|RI0/N151.12061,6.11309,3.59153,47.33409/Z4/"&gt;Avec JS : en mode interaction utilisateur&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Avec JS : en mode interaction utilisateur" src="/images/javascript/isomorph-w-js.png"&gt;&lt;/p&gt;
&lt;p&gt;Vous pouvez noter de subtiles différences : l'absence de carte ou de barre de catégories en version SEO.&lt;/p&gt;
&lt;p&gt;Comme vous l'avez peut-être compris, nous avons investi un peu de temps dans ce moteur de rendu. C'est une expérience très intéressante qui montre comment, en posant clairement un problème, en le découpant en plus petites cibles atteignables, on peut réussir à contruire quelque chose simple d'usage.&lt;/p&gt;
&lt;p&gt;Les objectifs de ce changement d'architecture étaient multiples : ne pas tout remettre en cause, évoluer sereinement vers une autre structure afin d'atteindre les ambitions stratégiques du produit.
Les changements apportés n'ont ont permis de livrer un code plus stable, plus facile à maintenir, plus testable donc plus couvert (de test unitaire).&lt;/p&gt;</content><category term="français"></category><category term="JavaScript"></category><category term="NodeJS"></category><category term="Backbone"></category></entry><entry><title>Backbone isomorphique maison : pourquoi ?</title><link href="https://techblog.mappy.com/pourquoi-backbone-isomorphique.html" rel="alternate"></link><published>2018-01-10T00:00:00+01:00</published><updated>2018-01-10T00:00:00+01:00</updated><author><name>Nicolas Bétheuil</name></author><id>tag:techblog.mappy.com,2018-01-10:/pourquoi-backbone-isomorphique.html</id><summary type="html">&lt;p&gt;Pourquoi-a-t'on réécrit une librairie isomorphique basée sur backbone ?&lt;/p&gt;</summary><content type="html">&lt;p&gt;Vous l'avez peut-être remarqué, nous avons refait une partie du site il y a bien six mois maintenant : les itinéraires. Nous appelons cela le multipath (prononcer &lt;a href="https://www.anglaisfacile.com/exercices/exercice-anglais-2/exercice-anglais-66477.php"&gt;moultipaðe&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Petit tour du propriétaire : vous pouvez dorénavant pour une recherche d'itinéraire avoir les réponses dans plusieurs modes de transport : voiture (évidemment), bus, car, taxi, VTC, transport en commun, à pied ... et beaucoup d'autres modes suivront.&lt;/p&gt;
&lt;p&gt;Comme pour n'importe quelle partie du site : le &lt;a href="https://www.wikiwand.com/fr/Optimisation_pour_les_moteurs_de_recherche"&gt;SEO&lt;/a&gt; est une exigence forte. Nos pages doivent répondre de la même manière pour un moteur de recherche que pour une navigation utilisateur classique.&lt;/p&gt;
&lt;p&gt;Lors de la &lt;a href="http://techblog.mappy.com/mappy-com-de-php-a-nodejs.html"&gt;migration de PHP vers NodeJS&lt;/a&gt; réalisée l'année dernière, une architecture a été posée avec une séparation nette entre la partie serveur sous &lt;code&gt;express&lt;/code&gt; et la partie cliente pilotant des vues &lt;code&gt;Backbone&lt;/code&gt;. Cela impliquait notamment deux manières complètement différentes de récupérer la donnée avant de rendre la vue. Nous souhaitions explorer d'autres pistes pour faire évoluer l'architecture sans tout refondre. La piste de l'isomorphisme a alors été suivie pour uniformiser cette récupération de donnée. Nous souhaitions également suivre de manière plus rigoureuse le design MV de backbone.&lt;/p&gt;
&lt;p&gt;Une autre contrainte était la courbe d'apprentissage et le délai que nous avions pour faire cette évolution stratégique du produit Mappy. Nous étions une équipe de cinq développeurs, les autres connaissaient déjà &lt;a href="http://backbonejs.org/"&gt;backbone&lt;/a&gt; et j'arrivais avec plus de connaissances sur &lt;a href="https://reactjs.org/"&gt;ReactJS&lt;/a&gt; et la refonte d'un autre site en isomorphique.&lt;/p&gt;
&lt;p&gt;Pour des raisons de "time to market", nous ne souhaitions pas migrer tout le site vers React. Par ailleurs, l’ajouter en plus de backbone, avec son ecosystème et ses ~40Kb minifiés &amp;amp; compressés était problèmatique pour des raisons de performance, notamment en mobile.&lt;/p&gt;
&lt;p&gt;L'idée était donc d'apporter une réponse proportionnée, adéquate, co-construite et réfléchie sans tout remettre en cause : l'architecture, les compétences de l'équipe et l'ambition stratégique du produit.&lt;/p&gt;
&lt;p&gt;Nous avons donc décidé de suivre cette voie de manière itérative. Tout d'abord par un POC (Proof Of Concept) puis par une intégration progressive dans les composants développés en s'attaquant à la plus grosse difficulté suivante.&lt;/p&gt;
&lt;p&gt;Nous avons commencé par un POC le 24 avril 2017 : en moins d'une semaine, nous avions une première version fonctionnelle qui montrait comment faire communiquer les composants entre eux avec un code applicatif identique entre la version cliente et serveur. Les nuances clients vs serveur étaient localisées dans ce que nous avons appelé plus tard AMIB pour Asynchronous Mappy Isomorphic Backbone. Le 11 mai, après avoir validé AMIB de façon collégiale en réunion technique, nous avons fusionné cette première version de travail fonctionnelle dans la branche principale ce qui a permis de partager le travail d'implémentation des vues avec les autres membres de l'équipe.&lt;/p&gt;
&lt;p&gt;Chez Mappy, nous avons la possibilité d'essayer, d'apprendre, d'expérimenter. On travaille ensemble à définir des objectifs, des modes de collaboration, des jalons, des étapes pour satisfaire les besoins qui nous sont exprimés.&lt;/p&gt;
&lt;p&gt;PS : Pour plus de notions / culture / références sur l'isomorphisme ... je vous laisse vous documenter si vous désirez en savoir plus : &lt;a href="https://medium.com/airbnb-engineering/isomorphic-javascript-the-future-of-web-apps-10882b7a2ebc"&gt;chez Airbnb&lt;/a&gt; ou &lt;a href="http://tech.m6web.fr/isomorphic-single-page-app-parfaite-react-flux/"&gt;chez M6&lt;/a&gt;.&lt;/p&gt;</content><category term="français"></category><category term="JavaScript"></category><category term="NodeJS"></category><category term="backbone"></category></entry><entry><title>mappy.com : de PHP à node.js</title><link href="https://techblog.mappy.com/mappy-com-de-php-a-nodejs.html" rel="alternate"></link><published>2017-01-26T00:00:00+01:00</published><updated>2017-01-26T00:00:00+01:00</updated><author><name>Grégory Paul</name></author><id>tag:techblog.mappy.com,2017-01-26:/mappy-com-de-php-a-nodejs.html</id><summary type="html">&lt;p&gt;Cet article présente la migration du site mappy.com de PHP à node.js&lt;/p&gt;</summary><content type="html">&lt;p&gt;Depuis quelques jours, le site web &lt;a href="https://fr.mappy.com/"&gt;mappy.com&lt;/a&gt; est entièrement servi par &lt;code&gt;node.js&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Historiquement sous &lt;code&gt;PHP&lt;/code&gt; et &lt;a href="https://symfony.com/"&gt;Symfony 2&lt;/a&gt;, une stratégie de migration a été mise en place pour migrer les serveurs web, page par page, vers &lt;code&gt;node.js&lt;/code&gt; et &lt;a href="http://expressjs.com/"&gt;express&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="php vers node" src="images/javascript/php-to-node.png"&gt;&lt;/p&gt;
&lt;h1&gt;Le site Web Mappy&lt;/h1&gt;
&lt;p&gt;Mappy est une « &lt;a href="https://fr.wikipedia.org/wiki/Application_web_monopage"&gt;single page application&lt;/a&gt; » qui se compose en 2 parties :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;une partie serveur, composée de pages HTML et de feuilles de style, majoritairement dédiées aux moteurs de recherche (&lt;a href="https://fr.wikipedia.org/wiki/Optimisation_pour_les_moteurs_de_recherche"&gt;SEO&lt;/a&gt;), afin de leur présenter les informations accessibles via l’application Web cliente,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;une partie cliente composée de JavaScript et s’exécutant dans le navigateur qui permet d’ajouter toute l’interactivité au site (notamment les interactions avec la carte, ce qui évite les rechargements de page après action de l’utilisateur).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ces parties serveur et cliente font appel aux nombreuses APIs &lt;a href="https://fr.wikipedia.org/wiki/Representational_State_Transfer"&gt;REST&lt;/a&gt; de Mappy afin de répondre aux besoins des internautes : service de recherche, de suggestion, de points d’intérêt (comme les commerces, hôtels, restaurants, etc), de calculs d’itinéraires, de statistiques, etc.
Ces services sont écrits dans différents autres langages adaptés à chacune de leur problématique (et ne seront pas traités dans le cadre de cet article).&lt;/p&gt;
&lt;h3&gt;Site sans JavaScript activé (pour le SEO)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="sans javascript" src="images/javascript/mappy-no-js.png"&gt;&lt;/p&gt;
&lt;h3&gt;Site avec JavaScript (pour les internautes)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="avec javascript" src="images/javascript/mappy-js.png"&gt;&lt;/p&gt;
&lt;h1&gt;Avant la migration node.js&lt;/h1&gt;
&lt;p&gt;Le site Mappy est une application Web composée d’environ 20000 lignes de code de JavaScript (sans compter les librairies) côté client (ou navigateur) et environ 11000 lignes de &lt;code&gt;PHP&lt;/code&gt; côté serveur (toujours sans compter les librairies).&lt;/p&gt;
&lt;p&gt;&lt;img alt="architecture avec PHP" src="images/javascript/portal-architecture-php.png"&gt;&lt;/p&gt;
&lt;p&gt;Le site utilise également des templates au format &lt;code&gt;twig&lt;/code&gt;, à la fois via le code JavaScript et &lt;code&gt;PHP&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Pourquoi node.js ?&lt;/h1&gt;
&lt;p&gt;La volonté de migrer le code &lt;code&gt;PHP&lt;/code&gt; vers JavaScript s’est faite pour principalement 3 raisons :&lt;/p&gt;
&lt;h2&gt;1. Même paradigme entre code client et code serveur&lt;/h2&gt;
&lt;p&gt;JavaScript est un langage asynchrone avec un système d’héritage par prototype alors que &lt;code&gt;PHP&lt;/code&gt; est un langage procédural avec un système d’héritage orienté classe.
Certaines fonctionnalités devant à la fois être disponibles côté client et à la fois côté serveur, il est nécessaire de les développer 2 fois de façon relativement différente.&lt;/p&gt;
&lt;h2&gt;2. Code partagé&lt;/h2&gt;
&lt;p&gt;Pour permettre le partage de code, nous avons, il y a quelques temps déjà, adopté &lt;code&gt;CommonJS&lt;/code&gt; pour notre code JavaScript client.
&lt;code&gt;CommonJS&lt;/code&gt; est un système de chargement de dépendances, utilisé par &lt;code&gt;node.js&lt;/code&gt;.
Nous utilisons &lt;code&gt;browserify&lt;/code&gt; pour traduire nos fichiers au format &lt;code&gt;CommonJS&lt;/code&gt; en un fichier JavaScript compréhensible par le navigateur.&lt;/p&gt;
&lt;p&gt;Environ 20 à 25 % de code est maintenant partagé, utilisé à la fois par le serveur et le client (exemple sur les pages de point d’intérêt, itinéraire, etc).&lt;/p&gt;
&lt;p&gt;Une conséquence de cela est une plus grande cohérence dans le comportement entre le serveur et le client (même traitement, même présentation des données).&lt;/p&gt;
&lt;h2&gt;3. Recrutement facilité&lt;/h2&gt;
&lt;p&gt;En éliminant &lt;code&gt;PHP&lt;/code&gt; de l’équation, le recrutement est facilité puisque nous ne recherchons que des experts en JavaScript (avec de bases solides en &lt;code&gt;CSS&lt;/code&gt;, &lt;code&gt;HTML&lt;/code&gt;, performances web, &lt;code&gt;GNU/Linux&lt;/code&gt;, &lt;code&gt;puppet&lt;/code&gt;, etc).
Vous pouvez d’ailleurs consulter notre page sur &lt;a href="https://remixjobs.com/company/MAPPY/140070/informations"&gt;RemixJobs&lt;/a&gt; si vous êtes intéressé.&lt;/p&gt;
&lt;h1&gt;Après la migration vers node.js&lt;/h1&gt;
&lt;p&gt;A l’issue de la migration, le code est toujours de 20000 lignes de code côté client mais une partie d’entre elles sont partagées par le serveur (modèles et collections &lt;code&gt;Backbone&lt;/code&gt; notamment).
Le code côté serveur n’est plus que d’environ 8000 lignes (sans le code partagé).&lt;/p&gt;
&lt;p&gt;&lt;img alt="architecture avec node" src="images/javascript/portal-architecture-node.png"&gt;&lt;/p&gt;
&lt;h2&gt;Impacts sur les temps de réponse&lt;/h2&gt;
&lt;p&gt;On constate un gain du temps de réponse moyen d’environ 10 % sur l’ensemble des pages du site.
Les pages consommant le plus d’appels aux services &lt;a href="https://fr.wikipedia.org/wiki/Representational_State_Transfer"&gt;REST&lt;/a&gt; montrent le plus gros gain (comme l’affichage des pages présentant les points d’intérêts par exemple).
C’est assez logique, &lt;code&gt;node.js&lt;/code&gt; étant particulièrement adapté aux multiples entrées / sorties (réseau ou disque) de par son côté asynchrone non bloquant.&lt;/p&gt;
&lt;p&gt;Ci-dessous un exemple des temps de réponse moyen des pages présentant les points d’intérêts avant et après la migration vers &lt;code&gt;node.js&lt;/code&gt; (séparée par la ligne verte) :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Temps de réponse de la page de point d’intérêt" src="images/javascript/response-time.png"&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;La migration vers &lt;code&gt;node.js&lt;/code&gt; est un succès.&lt;/p&gt;
&lt;p&gt;Tout d’abord, l’objectif de migration transparente a été complètement respecté. Il n’y a eu aucun impact négatif, ni pour les internautes, ni pour les performances SEO.&lt;/p&gt;
&lt;p&gt;Enfin, il est maintenant beaucoup plus facile d’intervenir sur le code serveur et le développement de fonctionnalités communes est plus rapide.&lt;/p&gt;
&lt;p&gt;Le seul inconvénient de cette migration « douce » est qu’elle s’est étendue sur plusieurs mois et donc a été relativement longue (les pages migrées ont été mises en ligne au fur et à mesure, en vérifiant l’absence d’impact négatif à chaque mise en production).&lt;/p&gt;
&lt;h2&gt;Et après ?&lt;/h2&gt;
&lt;p&gt;Symfony utilisant &lt;a href="http://twig.sensiolabs.org/"&gt;twig&lt;/a&gt; comme moteur de template par défaut, tous nos templates sont dans ce format, soit environ 30000 lignes de code.
Nous utilisons d’ailleurs &lt;a href="https://github.com/Mappy/twigify"&gt;twigify&lt;/a&gt; pour les utiliser via &lt;code&gt;browserify&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="architecture avec twig" src="images/javascript/portal-architecture-template.png"&gt;&lt;/p&gt;
&lt;p&gt;Twig étant une technologie issue du monde &lt;code&gt;PHP&lt;/code&gt;, elle n’est pas très adaptée à JavaScript.
Par conséquent, l’un de nos futurs chantiers technique est l’étude d’un successeur (mustache, jade, react ?) suivi de la migration des templates.&lt;/p&gt;
&lt;p&gt;Nous espérons à nouveau un gain de performances lié à cette migration, notamment en abandonnant l’héritage au sein des templates.&lt;/p&gt;</content><category term="français"></category><category term="javascript"></category><category term="node.js"></category></entry></feed>